[{"title":"Java工程师成神之路","url":"/2020/03/30/index/","content":"Java工程师成神之路\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### **一、基础篇**\n#### 1.1、Java基础 \n* 面向对象的特征：继承、封装和多态\n* final, finally, finalize 的区别\n* Exception、Error、运行时异常与一般异常有何异同\n* 请写出5种常见到的runtime exception\n* int 和 Integer 有什么区别，Integer的值缓存范围\n* 包装类，装箱和拆箱\n* String、StringBuilder、StringBuffer\n* 重载和重写的区别\n* 抽象类和接口有什么区别\n* 说说反射的用途及实现\n* 说说自定义注解的场景及实现\n* HTTP请求的GET与POST方式的区别\n* Session与Cookie区别\n* 列出自己常用的JDK包\n* MVC设计思想\n* equals与==的区别\n* hashCode和equals方法的区别与联系\n* 什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用\n* Object类中常见的方法，为什么wait  notify会放在Object里边？\n* Java的平台无关性如何体现出来的\n* JDK和JRE的区别\n* Java 8有哪些新特性\n#### 1.2、Java常见集合\n* List 和 Set 区别\n* Set和hashCode以及equals方法的联系\n* List 和 Map 区别\n* Arraylist 与 LinkedList 区别\n* ArrayList 与 Vector 区别\n* HashMap 和 Hashtable 的区别\n* HashSet 和 HashMap 区别\n* HashMap 和 ConcurrentHashMap 的区别\n* HashMap 的工作原理及代码实现，什么时候用到红黑树\n* 多线程情况下HashMap死循环的问题\n* HashMap出现Hash DOS攻击的问题\n* ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数\n* 手写简单的HashMap\n* 看过那些Java集合类的源码\n#### 1.3、进程和线程\n* 线程和进程的概念、并行和并发的概念\n* 创建线程的方式及实现\n* 进程间通信的方式\n* 说说 CountDownLatch、CyclicBarrier 原理和区别\n* 说说 Semaphore 原理\n* 说说 Exchanger 原理\n* ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理\n* 讲讲线程池的实现原理\n* 线程池的几种实现方式\n* 线程的生命周期，状态是如何转移的\n  可参考：《Java多线程编程核心技术》\n#### 1.4、锁机制\n* 说说线程安全问题，什么是线程安全，如何保证线程安全\n* 重入锁的概念，重入锁为什么可以防止死锁\n* 产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）\n* 如何检查死锁（通过jConsole检查死锁）\n* volatile 实现原理（禁止指令重排、刷新内存）\n* synchronized 实现原理（对象监视器）\n* synchronized 与 lock 的区别\n* AQS同步队列\n* CAS无锁的概念、乐观锁和悲观锁\n* 常见的原子操作类\n* 什么是ABA问题，出现ABA问题JDK是如何解决的\n* 乐观锁的业务场景及实现方式\n* Java 8并法包下常见的并发类\n* 偏向锁、轻量级锁、重量级锁、自旋锁的概念\n  可参考：《Java多线程编程核心技术》\n#### 1.5、JVM\n* JVM运行时内存区域划分\n* 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决\n* 如何判断对象是否可以回收或存活\n* 常见的GC回收算法及其含义\n* 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等\n* JVM如何设置参数\n* JVM性能调优\n* 类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的\n* 类加载的过程：加载、验证、准备、解析、初始化\n* 强引用、软引用、弱引用、虚引用\n* Java内存模型JMM\n#### 1.6、设计模式\n* 常见的设计模式\n* 设计模式的的六大原则及其含义\n* 常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式\n* 设计模式在实际场景中的应用\n* Spring中用到了哪些设计模式\n* MyBatis中用到了哪些设计模式\n* 你项目中有使用哪些设计模式\n* 说说常用开源框架中设计模式使用分析\n   动态代理很重要！！！\n#### 1.7、数据结构\n* 树（二叉查找树、平衡二叉树、红黑树、B树、B+树）\n* 深度有限算法、广度优先算法\n* 克鲁斯卡尔算法、普林母算法、迪克拉斯算法\n* 什么是一致性Hash及其原理、Hash环问题\n* 常见的排序算法和查找算法：快排、折半查找、堆排序等\n#### 1.8、网络/IO基础\n* BIO、NIO、AIO的概念\n* 什么是长连接和短连接\n* Http1.0和2.0相比有什么区别，可参考《Http 2.0》\n* Https的基本概念\n* 三次握手和四次挥手、为什么挥手需要四次\n* 从游览器中输入URL到页面加载的发生了什么？可参考《从输入URL到页面加载发生了什么》\n### 二、数据存储和消息队列\n#### 2.1、数据库\n* MySQL 索引使用的注意事项\n* DDL、DML、DCL分别指什么\n* explain命令\n* left join，right join，inner join\n* 数据库事物ACID（原子性、一致性、隔离性、持久性）\n* 事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）\n* 脏读、幻读、不可重复读\n* 数据库的几大范式\n* 数据库常见的命令\n* 说说分库与分表设计\n* 分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）\n* 说说 SQL 优化之道\n* MySQL遇到的死锁问题、如何排查与解决\n* 存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景\n* 索引类别（B+树索引、全文索引、哈希索引）、索引的原理\n* 什么是自适应哈希索引（AHI）\n* 为什么要用 B+tree作为MySQL索引的数据结构\n* 聚集索引与非聚集索引的区别\n* 遇到过索引失效的情况没，什么时候可能会出现，如何解决\n* limit 20000 加载很慢怎么解决\n* 如何选择合适的分布式主键方案\n* 选择合适的数据存储方案\n* 常见的几种分布式ID的设计方案\n* 常见的数据库优化方案，在你的项目中数据库如何进行优化的\n#### 2.2、Redis\n* Redis 有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》\n* Redis 内部结构\n* Redis 使用场景\n* Redis 持久化机制，可参考《使用快照和AOF将Redis数据持久化到硬盘中》\n* Redis 集群方案与实现\n* Redis 为什么是单线程的？\n* 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级\n* 使用缓存的合理性问题\n* Redis常见的回收策略\n#### 2.3、消息队列\n* 消息队列的使用场景\n* 消息的重发补偿解决思路\n* 消息的幂等性解决思路\n* 消息的堆积解决思路\n* 自己如何实现消息队列\n* 如何保证消息的有序性\n### 三、开源框架和容器\n#### 3.1、SSM/Servlet\n* Servlet的生命周期\n* 转发与重定向的区别\n* BeanFactory 和 ApplicationContext 有什么区别\n* Spring Bean 的生命周期\n* Spring IOC 如何实现\n* Spring中Bean的作用域，默认的是哪一个\n* 说说 Spring AOP、Spring AOP 实现原理\n* 动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择\n* Spring 事务实现方式、事务的传播机制、默认的事务类别\n* Spring 事务底层原理\n* Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《JDK动态代理给Spring事务埋下的坑！》\n* 如何自定义注解实现功能\n* Spring MVC 运行流程\n* Spring MVC 启动流程\n* Spring 的单例实现原理\n* Spring 框架中用到了哪些设计模式\n* Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）\n* 有没有用到Spring Boot，Spring Boot的认识、原理\n* MyBatis的原理\n    可参考《为什么会有Spring》\n    可参考《为什么会有Spring AOP》\n#### 3.2、Netty\n* 为什么选择 Netty\n* 说说业务中，Netty 的使用场景\n* 原生的 NIO 在 JDK 1.7 版本存在 epoll bug\n* 什么是TCP 粘包/拆包\n* TCP粘包/拆包的解决办法\n* Netty 线程模型\n* 说说 Netty 的零拷贝\n* Netty 内部执行流程\n* Netty 重连实现\n#### 3.3、Tomcat\n* Tomcat的基础架构（Server、Service、Connector、Container）\n* Tomcat如何加载Servlet的\n* Pipeline-Valve机制\n    可参考：《四张图带你了解Tomcat系统架构！》\n### 四、分布式\n#### 4.1、Nginx\n* 请解释什么是C10K问题或者知道什么是C10K问题吗？\n* Nginx简介，可参考《Nginx简介》\n* 正向代理和反向代理.\n* Nginx几种常见的负载均衡策略\n* Nginx服务器上的Master和Worker进程分别是什么\n* 使用“反向代理服务器”的优点是什么?\n#### 4.2、分布式其他\n* 谈谈业务中使用分布式的场景\n* Session 分布式方案\n* Session 分布式处理\n* 分布式锁的应用场景、分布式锁的产生原因、基本概念\n* 分布是锁的常见解决方案\n* 分布式事务的常见解决方案\n* 集群与负载均衡的算法与实现\n* 说说分库与分表设计，可参考《数据库分库分表策略的具体实现方案》\n* 分库与分表带来的分布式困境与应对之策\n#### 4.3、Dubbo\n* 什么是Dubbo，可参考《Dubbo入门》\n* 什么是RPC、如何实现RPC、RPC 的实现原理，可参考《基于HTTP的RPC实现》\n* Dubbo中的SPI是什么概念\n* Dubbo的基本原理、执行流程\n### 五、微服务\n#### 5.1、微服务\n* 前后端分离是如何做的？\n* 微服务哪些框架\n* Spring Could的常见组件有哪些？可参考《Spring Cloud概述》\n* 领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型\n* JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》\n* 你怎么理解 RESTful\n* 说说如何设计一个良好的 API\n* 如何理解 RESTful API 的幂等性\n* 如何保证接口的幂等性\n* 说说 CAP 定理、BASE 理论\n* 怎么考虑数据一致性问题\n* 说说最终一致性的实现方案\n* 微服务的优缺点，可参考《微服务批判》\n* 微服务与 SOA 的区别\n* 如何拆分服务、水平分割、垂直分割\n* 如何应对微服务的链式调用异常\n* 如何快速追踪与定位问题\n* 如何保证微服务的安全、认证\n#### 5.2、安全问题\n* 如何防范常见的Web攻击、如何方式SQL注入\n* 服务端通信安全攻防\n* HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比\n#### 5.3、性能优化\n* 性能指标有哪些\n* 如何发现性能瓶颈\n* 性能调优的常见手段\n* 说说你在项目中如何进行性能调优\n### 六、其他\n#### 6.1、设计能力\n* 说说你在项目中使用过的UML图\n* 你如何考虑组件化、服务化、系统拆分\n* 秒杀场景如何设计\n  可参考：《秒杀系统的技术挑战、应对策略以及架构设计总结一二！》\n#### 6.2、业务工程\n* 说说你的开发流程、如何进行自动化部署的\n* 你和团队是如何沟通的\n* 你如何进行代码评审\n* 说说你对技术与业务的理解\n* 说说你在项目中遇到感觉最难Bug，是如何解决的\n* 介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方\n#### 6.3、软实力\n* 说说你的优缺点、亮点\n* 说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码\n* 说说你觉得最有意义的技术书籍\n* 工作之余做什么事情、平时是如何学习的，怎样提升自己的能力\n* 说说个人发展方向方面的思考\n* 说说你认为的服务端开发工程师应该具备哪些能力\n* 说说你认为的架构师是什么样的，架构师主要做什么\n*  如何看待加班的问题\n \n 当然，一个完整的面试肯定不止上述的知识点，其他的诸如：Linux、数据结构、算法、逻辑思维题、系统设计题、职业规划等等都会有所涉及\n\n \n### **二、进阶篇**\n  \n### **三、高级篇**\n   \n### **四、架构篇**\n\n","categories":["学习笔记"]},{"title":"配置中心","url":"/2019/05/17/ConfigCentre/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n各种功能的开关、参数的配置、服务器的地址...配置修改后实时生效，灰度发布，分环境、分集群管理配置，完善的权限、审核机制...\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 一、有哪些开源配置中心\n\n* spring-cloud/spring-cloud-config\nhttps://github.com/spring-cloud/spring-cloud-config\nspring出品，可以和spring cloud无缝配合\n\n* 淘宝 diamond\nhttps://github.com/takeseem/diamond\n已经不维护\n\n* disconf\nhttps://github.com/knightliao/disconf\njava开发，蚂蚁金服技术专家发起，业界使用广泛\n\n* ctrip apollo\nhttps://github.com/ctripcorp/apollo/\nApollo（阿波罗）是携程框架部门研发的开源配置管理中心，具备规范的权限、流程治理等特性。\n\n### 二、配置中心对别\n\n### 三、技术路线兼容性\n| 功能点 | 优先级 |  spring-cloud-config  |  ctrip apollo  |  disconf  | \n| :----: | :----: | :----: | :----: | :----: |\n| SpringBoot支持 | 高 |  原生支持 |  支持 |  disconf  |   \n| SpringCloud支持 | 高 | 原生支持  |  支持  |  disconf  |    \n| 客户端支持 | 低 |  Java  |  Java、.Net  |  Java  |  备注  |\n| 业务系统侵入性 | 高 | 侵入性弱  |  侵入性弱  |  侵入性弱 ，支持注解及xml方式\t  | \n| 依赖组件 | 高 |  Eureka  |  Eureka  |  zookeeper  |  \n### 四、可用性与易用性\n","categories":["研发工具"]},{"title":"数据库连接池DBCP","url":"/2019/05/15/DBCP/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nDBCP（DataBase Connection Pool）数据库连接池，是Java数据库连接池的一种，通过数据库连接池，可以让程序自动管理数据库连接的释放和断开。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 一、DRDS\n","categories":["玩转框架"]},{"title":"开发工具","url":"/2019/05/15/tools_use/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n本平台的前端基于vue、element-ui构建开发，实现后台管理前端功能，提供一套更优的前端解决方案。后端按模块化的结构实现组件化的扩展。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 一、体系结构\n\n| 水果        | 价格    |  数量  |\n| --------   | -----:   | :----: |\n| 香蕉        | $1      |   5    |\n| 苹果        | $1      |   6    |\n| 草莓        | $1      |   7    |\n\n### 二、技术架构\n\n使用 [^keyword] 表示注脚。\n\n这是一个注脚[^footnote]的样例。\n\n这是第二个注脚[^footnote2]的样例。\n\n```flow\nst=>start: Startswww\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```","categories":["研发工具"]},{"title":"基础开发平台","url":"/2019/05/15/leonard_demo_project/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n本平台的前端基于vue、element-ui构建开发，实现后台管理前端功能，提供一套更优的前端解决方案。后端按模块化的结构实现组件化的扩展。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 一、体系结构\n\n| 水果        | 价格    |  数量  |\n| --------   | -----:   | :----: |\n| 香蕉        | $1      |   5    |\n| 苹果        | $1      |   6    |\n| 草莓        | $1      |   7    |\n\n### 二、技术架构\n\n使用 [^keyword] 表示注脚。\n\n这是一个注脚[^footnote]的样例。\n\n这是第二个注脚[^footnote2]的样例。\n\n```flow\nst=>start: Startswww\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```","categories":["玩转框架"]},{"title":"分布式关系型数据库 DRDS","url":"/2018/09/14/ali-drds-01/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n分布式关系型数据库服务（Distributed Relational Database Service，简称 DRDS）\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 一、什么是分布式对象存储\n    分布式对象存储服务可以对外提供海量，安全，低成本，高可靠的云存储服务。分布\n    式对象存储服务屏蔽了底层存储硬件设备及技术，通过 RESTful 接口为用户提供高性\n    能，高可用性，可无限扩展的海量文件存储服务。用户可以通过 RESTFul 接口，在任\n    何时间、任何地点、任何互联网设备上进行上传和下载数据，也可以使用 WEB 控制\n    台进行管理。\n    同时，分布式对象存储服务提供 Java、 Python、 PHP、.NET、Android、IOS、Go、\n    Ruby、JS 语言的 SDK，简化服务端和移动端的开发。基于分布式对象存储服务，用\n    户可以搭建出多媒体视频、图片分享、个人和企业数据备份、移动应用等基于大规模\n    数据的服务。\n### 二、产品特点\n    * 海量存储 无线扩容\n    * 安全\n    * 可靠\n    * 性能卓越\n### 三、\n    \n### 四、\n### 五、\n### 六、\n### 七、","categories":["阿里云技术"]},{"title":"分布式对象存储OSS","url":"/2018/09/14/ali-occ-01/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n海量、安全、低成本、高可靠的云存储服务，提供99.999999999%的数据可靠性。使用RESTful API 可以在互联网任何位置存储和访问，容量和处理能力弹性扩展，多种存储类型供选择全面优化存储成本。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 一、什么是分布式对象存储\n    分布式对象存储服务可以对外提供海量，安全，低成本，高可靠的云存储服务。分布\n    式对象存储服务屏蔽了底层存储硬件设备及技术，通过 RESTful 接口为用户提供高性\n    能，高可用性，可无限扩展的海量文件存储服务。用户可以通过 RESTFul 接口，在任\n    何时间、任何地点、任何互联网设备上进行上传和下载数据，也可以使用 WEB 控制\n    台进行管理。\n    同时，分布式对象存储服务提供 Java、 Python、 PHP、.NET、Android、IOS、Go、\n    Ruby、JS 语言的 SDK，简化服务端和移动端的开发。基于分布式对象存储服务，用\n    户可以搭建出多媒体视频、图片分享、个人和企业数据备份、移动应用等基于大规模\n    数据的服务。\n### 二、产品特点\n    * 海量存储 无线扩容\n    * 安全\n    * 可靠\n    * 性能卓越\n### 三、\n    \n### 四、\n### 五、\n### 六、\n### 七、","categories":["阿里云技术"]},{"title":"软考高级架构师","url":"/2018/09/14/high_soft_examination/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n软件设计师考试属于全国计算机技术与软件专业技术资格考试（即软考）中的一个中级考试。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 一、什么是分布式对象存储\n    分布式对象存储服务可以对外提供海量，安全，低成本，高可靠的云存储服务。分布\n    式对象存储服务屏蔽了底层存储硬件设备及技术，通过 RESTful 接口为用户提供高性\n    能，高可用性，可无限扩展的海量文件存储服务。用户可以通过 RESTFul 接口，在任\n    何时间、任何地点、任何互联网设备上进行上传和下载数据，也可以使用 WEB 控制\n    台进行管理。\n    同时，分布式对象存储服务提供 Java、 Python、 PHP、.NET、Android、IOS、Go、\n    Ruby、JS 语言的 SDK，简化服务端和移动端的开发。基于分布式对象存储服务，用\n    户可以搭建出多媒体视频、图片分享、个人和企业数据备份、移动应用等基于大规模\n    数据的服务。\n### 二、产品特点\n    * 海量存储 无线扩容\n    * 安全\n    * 可靠\n    * 性能卓越\n### 三、\n    \n### 四、\n### 五、\n### 六、\n### 七、","categories":["阿里云技术"]},{"title":"软考中级软件设计师","url":"/2018/09/14/soft_examination/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n软件设计师考试属于全国计算机技术与软件专业技术资格考试（即软考）中的一个中级考试。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 一、考试相关信息\n    \n## 二、上午考试-计算机基础\n* 一、计算机基本知识 (1-6/6分/8%/难度中等)\n* 二、程序语言基本知识(20-22 & 48-50/6分/8%/难度中等)\n* 三、操作系统基本知识(23-28/6分/8%/难度适中)\n* 四、系统开发和运行(12-14分/20%/难度偏难)\n* 五、网络基础知识(7-9 & 66-70/8分/11%/难度不高)\n* 六、多媒体基础知识(3分/4%/难度较低)\n* 七、数据库技术(6分/8%/难度中等偏上)\n* 八、数据结构(4-7分/5%-9%/难度中等偏难)\n* 九、算法设计与分析(61-65/5分/5%/难度较高)\n* 十、面向对象技术(38-37/10-11分/13%-15%/难度中等偏难)\n* 十一、标准化和知识产权基本知识(13-14/2分/3%/难度不高)\n* 十二、计算机专业英语(71-75/5分/6%/难度中等)\n\n## 三、下午考试-软件设计\n\n* 第一题 (系统开发和运行)数据流图(挖空填空 外部实体/数据存储/数据流图的平衡)\n* 第二题 (数据库技术)数据库E-R图设计(挖空填空 关系连线/表字段设计/开方试题)\n* 第三题 (面向对象技术)UML图设计(挖空填空 设计模式/设计模式原理)\n* 第四题 (数据结构&算法)算法设计(挖空填空 填语句/分析算法时间和空间复杂度) (动态规划/分冶法/贪心)\n* 第五/六题 (面向对象技术)Java&C++程序设计(填写语句)\n   ### 1.数据流图\n   \n   \n   ### 2.数据库E-R图\n    ","categories":["阿里云技术"]},{"title":"分布式服务技术","url":"/2018/09/12/ali-service-01/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n分布式服务框架是企业级互联网架构解决方案的核心产品，充分利用天宫平台现有资\n源管理和服务体系，引入中间件成熟的整套分布式计算框架（包括分布式服务化框架、\n服务治理、运维管控、链路追踪和稳定性组件等），以应用为中心，帮助企业级客户轻\n松构建并托管分布式应用服务体系。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n","categories":["阿里云技术"]},{"title":"Centos7上安装Docker","url":"/2018/08/30/Centos7上安装docker/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n分布式系统不是万能，不能解决所有痛点。在高可用，一致性，分区容错性必须有所权衡。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n#### 一、What is Docker? \n正如[Docker官网](https://docs.docker.com/)介绍的那样：\n\n\tDocker is the world’s leading software containerization platform.\n \n\nDocker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。\n\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n\n#### 二、Centos7安装Docker\n\n1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。\n\n通过 uname -r 命令查看你当前的内核版本\n\n    $ uname -r\n2、使用 root 权限登录 Centos。确保 yum 包更新到最新。\n\n    $ sudo yum update\n3、卸载旧版本(如果安装过旧版本的话)\n\n    $ sudo yum remove docker  docker-common docker-selinux docker-engine\n4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\n\n    $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n5、设置yum源\n\n    $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n![upload successful](\\images\\docker\\pasted-1.png)\n6、可以查看所有仓库中所有docker版本，并选择特定版本安装\n\n    $ yum list docker-ce --showduplicates | sort -r\n![upload successful](\\images\\docker\\pasted-0.png)\n\n7、安装docker\n\n    $ sudo yum install docker-ce  #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0\n    $ sudo yum install <FQPN>  # 例如：sudo yum install docker-ce-17.12.0.ce\n    \n![upload successful](\\images\\docker\\pasted-2.png)\n\n8、启动并加入开机启动\n\n    $ sudo systemctl start docker\n    $ sudo systemctl enable docker\n9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)\n\n    $ docker version\n       \n![upload successful](\\images\\docker\\pasted-3.png)","categories":["研发工具"]},{"title":"Phoenix操作hbase语句","url":"/2018/08/30/phoenix/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nhbase 提供很方便的shell脚本，可以对数据表进行 CURD 操作，但是毕竟是有一定的学习成本的，基本上对于开发来讲，\nsql 语句都是看家本领，那么，有没有一种方法可以把 sql 语句转换成 hbase的原生API呢？ 这样就可以通过普通平常的 sql 来对hbase 进行数据的管理，使用成本大大降低。Apache Phoenix 组件就完成了这种需求\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n创建表：\n\n    CREATE TABLE \"TEST\" (\n    \"ROW\" VARCHAR PRIMARY KEY,\n    \"ORDER_LINE_ID\" VARCHAR,\n    \"ORDER_ID\" VARCHAR,\n    \"IN_MODE_CODE\" VARCHAR\n    )\n\n表赋值：\n\n    upsert into TEST values('000027effafe62a196bd8012b0dd439ad1b0294a15000','NY','NewYork','8143197');\n\n删除表：\n    \n    drop table TEST；\n\n删除记录：\n\n    delete from TEST where ORDER_ID='NewYork';\n\n查找表：\n    \n    SELECT * FROM TEST LIMIT 1;\n\n添加表字段：\n\n    ALTER TABLE TEST ADD PRODUCT_ID VARCHAR;\n\n删除表字段：\n    \n    ALTER TABLE TEST  DROP COLUMN PRODUCT_ID;","categories":["大数据"]},{"title":"Gitlab服务器搭建","url":"/2018/08/29/gitlab-ce/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nGitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n#### 一：安装步骤\n##### 1、安装\n    ##安装\n    sudo yum install gitlab-ce\n    \n    #配置itLab\n    sudo gitlab-ctl reconfigure\n    ##gitlab-ctl reconfigure\n    ##出现：ruby_block[supervise_redis_sleep] action run，会一直卡无法往下进行\n    ##解决方案：\n    ##1. 按住CTRL+C强制结束\n    ##2. 运行：sudo systemctl restart gitlab-runsvdir\n    ##3. 再次执行：sudo gitlab-ctl reconfigure\n    \n    ##启动Gitlab服务\n    sudo gitlab-ctl restart\n ##### 2、修改配置   \n\n    vi /etc/gitlab/gitlab.rb\n    \n    ## 修改客户端访问地址，配置域名\n    ## GitLab URL\n    ##! URL on which GitLab will be reachable.\n    ##! For more details on configuring external_url see:\n    ##! https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab\n    external_url 'http://gitlab.capd.net'\n    \n    \n    ## 更改代码仓库的默认目录\n    ### For setting up different data storing directory\n    ###! Docs: https://docs.gitlab.com/omnibus/settings/configuration.html#storing-git-data-in-an-alternative-directory\n    ###! **If you want to use a single non-default directory to store git data use a\n    ###!   path that doesn't contain symlinks.**\n    git_data_dirs({\n      \"default\" => {\n        \"path\" => \"/aifs/gitlab/git-data\"\n       }\n    })\n    \n    ###### \n    #git_data_dir has been deprecated since 8.10 and was removed in 11.0. Use git_data_dirs instead.\n    ######\n    \n    ################################################################################\n    ## gitlab.yml configuration\n    ##! Docs: https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/gitlab.yml.md\n    ################################################################################\n    \n    ### Email Settings\n    gitlab_rails['gitlab_email_enabled'] = true\n    gitlab_rails['gitlab_email_from'] = 'cuc-tc-capd@asiainfo.com'\n    gitlab_rails['gitlab_email_display_name'] = 'CUC TC-CAPD ADMIN'\n    gitlab_rails['gitlab_email_reply_to'] = 'cuc-tc-capd@asiainfo.com'\n    gitlab_rails['gitlab_email_subject_suffix'] = ''\n    \n    ### GitLab email server settings\n    ###! Docs: https://docs.gitlab.com/omnibus/settings/smtp.html\n    ###! **Use smtp instead of sendmail/postfix.**\n    \n    gitlab_rails['smtp_enable'] = true\n    gitlab_rails['smtp_address'] = \"mail.asiainfo.com\"\n    gitlab_rails['smtp_port'] = 25\n    gitlab_rails['smtp_user_name'] = \"cuc-tc-capd@asiainfo.com\"  ##必须是邮箱名\n    gitlab_rails['smtp_password'] = \"Gl123456\"\n    gitlab_rails['smtp_domain'] = \"asiainfo.com\"\n    gitlab_rails['smtp_authentication'] = \"login\"\n    gitlab_rails['smtp_enable_starttls_auto'] = true\n    gitlab_rails['smtp_tls'] = false\n    \n    vi /var/opt/gitlab/gitlab-rails/etc/gitlab.yml\n    \n    ##域名配置\n    ## Web server settings (note: host is the FQDN, do not include http://)\n    host: gitlab.capd.net\n    \n    ## Email settings\n    # Uncomment and set to false if you need to disable email sending from GitLab (default: true)\n    #email_from: gitlab@gitlab.capd.net\n    email_from: cuc-tc-capd@asiainfo.com\n    \n #### 二：卸载步骤\n     ## 停止gitlab\n     sudo gitlab-ctl stop\n     ## 卸载gitlab\n     sudo rpm -e gitlab-ce\n     ## 查看gitlab进程\n     ps -ef|grep gitlab\n     \n     ## 杀掉第一个守护进程\n     kill -9 6031\n     # 再次查看gitlab进程是否存在\n     ps -ef|grep gitlab\n     \n     ## 删除gitlab文件\n     #  删除所有包含gitlab的文件及目录\n     find / -name gitlab|xargs rm -rf\n\n修改gitlab.rb、gitlab.yml需重启服务\n\n    sudo gitlab-ctl reconfigure\n    sudo gitlab-ctl restart\n    sudo gitlab-ctl status\n","categories":["研发工具"]},{"title":"Gitlab-CI安装","url":"/2018/08/29/gitlab-ci/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nGitLab持续集成（CI）：是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误\n<!-- more -->\n<The rest of contents | 余下全文>\n\n#### 一：安装步骤\n\n#### 1、安装\n    sudo yum install gitlab-runner\n    \n    ##查看runner配置信息\n    gitlab-runner list\n    #也可以直接打开配置文件进行查看 \n    vi /etc/gitlab-runner/config.toml\n    \n    ##部分GitLab-Runner常用命令\n    1. gitlab-runner帮助：gitlab-runner –help\n    2. gitlab-runner指定命令帮助：gitlab-runner <commond> –help\n    3. 注册runner：gitlab-runner register\n    4. 注销runner：gitlab-runner unregister\n    5. 当前运行的runner：gitlab-runner list\n    6. 启动runner：gitlab-runner start\n    7. 停止runner：gitlab-runner stop\n    8. 重启runner：gitlab-runner restart\n    9. 查询runner状态：gitlab-runner status\n    其他runner命令可以查询官网介绍：\n    https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/blob/master/docs/commands/README.md\n\n##### 2.注册runner\n    sudo gitlab-runner register\n\n #### 二：卸载步骤\n    rpm -qa|grep +你安装的名字 搜索不到证明你没有安装成功\n    rpm -ql +你安装程序的名字 这能搜索到你安装成功的程序位置。\n    rpm -e --noscripts ** 不考虑依赖卸载\n    \n    rpm -qa|grep gitlab-runner\n    \n    rpm -e gitlab-runner-11.2.0-1.x86_64\n    \n     #删除相关文件\n     find / -name gitlab-runner\n     find / -name gitlab-runner|xargs rm -rf\n    \n    #删除runner的用户\n    userdel gitlab_runner\n    userdel gitlab_ci_multi_runner","categories":["研发工具"]},{"title":"Hexo + Gitlab光速搭建博客并实现Git服务器自动部署","url":"/2018/08/29/hexo-gitlab/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n分布式系统不是万能，不能解决所有痛点。在高可用，一致性，分区容错性必须有所权衡。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n#### 第一步：安装node.js\n##### 1、Windows下安装node\n   Windows下安装直接下载软件包，执行就好。\n   安装完成后，在Windows环境下，请打开命令提示符，然后输入node -v，如果安装正常，你应该看到v7.6.0这样的输出：\n   \n![upload successful](\\images\\hexo\\pasted-1.png)\n\n其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入npm -v，应该看到类似的输出：\n\n![upload successful](\\images\\hexo\\pasted-2.png)\n\n##### 2、Linux下安装node\n（1）下载nodejs程序包\n网址：https://nodejs.org/en/download/\n\n![upload successful](\\images\\hexo\\pasted-3.png)\n\n （2）把程序包上传到服务器\n\n![upload successful](\\images\\hexo\\pasted-4.png)\n\n（3）加压压缩包\n\ttar -xvf node-v10.8.0-linux-x64.tar.xz\n\n（4）重命名文件夹\n\tmv node-v10.8.0-linux-x64 nodejs\n    \n （5）建立软链接，配置全局环境变量\n\n\tln -s /usr/local/node/nodejs/bin/npm /usr/local/bin/\n\n\tln -s /usr/local/node/nodejs/bin/node /usr/local/bin/\n\n （6）检查是否配置成功\n\tnode -v\n\n\tnpm -v\n\n2.把程序包上传到服务器\n\n#### 第二步：安装hexo并初始化项目\n\n    npm install -g hexo-cli\n\n  安装成功后切换到你想要创建博客的目录，然后执行\n\n    hexo init <folder>\n     cd <folder>\n     npm install\n  其中folder为博客目录名称，换成你想要的名称即可\n  至此，第一步已经完成。得到如下源文件：\n  \n![upload successful](\\images\\hexo\\pasted-0.png)\n\n#### 第三步：安装git\n\n#### 第四步：上传项目到gitlab上\n\n#### 第五步：Gitlab-CI实现\n ##### 1、名词解释\n  （1）Gitlab-CI\n Gitlab-CI是GitLab Continuous Integration（Gitlab持续集成）的简称。\n \n 从Gitlab的8.0版本开始，gitlab就全面集成了Gitlab-CI,并且对所有项目默认开启。\n \n 只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次合并请求（MR）或者push都会触发CI pipeline。\n \n  （2）Gitlab-runner\n   \n   Gitlab-runner是.gitlab-ci.yml脚本的运行器，Gitlab-runner是基于Gitlab-CI的API进行构建的相互隔离的机器（或虚拟机）。GitLab Runner 不需要和Gitlab安装在同一台机器上，但是考虑到GitLab Runner的资源消耗问题和安全问题，也不建议这两者安装在同一台机器上。\n\nGitlab Runner分为两种，Shared runners和Specific runners。\nSpecific runners只能被指定的项目使用，Shared runners则可以运行所有开启 Allow shared runners选项的项目。\n\n（3）Pipelines\nPipelines是定义于.gitlab-ci.yml中的不同阶段的不同任务。\n我把Pipelines理解为流水线，流水线包含有多个阶段（stages），每个阶段包含有一个或多个工序（jobs），比如先购料、组装、测试、包装再上线销售，每一次push或者MR都要经过流水线之后才可以合格出厂。而.gitlab-ci.yml正是定义了这条流水线有哪些阶段，每个阶段要做什么事。\n\n（4）Badges\n徽章，当Pipelines执行完成，会生成徽章，你可以将这些徽章加入到你的README.md文件或者你的网站。\n\n ##### 2、安装配置\n 这里跳过Gitlab的安装\n \n ##### 安装gitlab-ci-multi-runner\n （1）添加Gitlab的官方源\n \n     #ForCentOS\n     curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash\n （2）安装\n    \n    sudo yum install gitlab-ci-multi-runner\n \n （3）注册Runner\n \n Runner需要注册到Gitlab才可以被项目所使用，一个gitlab-ci-multi-runner服务可以注册多个Runner\n     ## http://gitlab.capd.net/\n     ## jgbar32kmvaafJvoNH2o\n     \n     sudo gitlab-ci-multi-runner register\n     \n     Running in system-mode.                            \n                                                        \n     Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):\n     http://gitlab.capd.net/\n     Please enter the gitlab-ci token for this runner:\n     jgbar32kmvaafJvoNH2o\n     Please enter the gitlab-ci description for this runner:\n     [host-10-1-241-33]: mytest\n     Please enter the gitlab-ci tags for this runner (comma separated):\n     test\n     Whether to run untagged builds [true/false]:\n     [false]: true\n     Whether to lock Runner to current project [true/false]:\n     [false]: \n     Registering runner... succeeded                     runner=jgbar32k\n     Please enter the executor: docker, docker-ssh, parallels, ssh, docker-ssh+machine, shell, virtualbox, docker+machine, kubernetes:\n     shell\n     Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! \n  （4）更新Runner\n  如果需要更新Runner，只需要执行以下脚本： \n    \n    #For CentOS\n    sudo yum update\n    sudo yum install gitlab-ci-multi-runner\n \n （5）Runner高级配置\n  通过gitlab-ci-multi-runner register注册的Runner配置会存储在/etc/gitlab-runner/config.toml中，如果需要修改可直接编辑该文件\n\n    concurrent = 1\n    check_interval = 0\n    [[runners]]\n      name = \"matesr\"\n      url = \"http://gitlab.capd.net/\"\n      token = \"977bec174e00a0960f6b3133d7f3c3\"\n      executor = \"shell\"\n      [runners.cache]\n    \n    [[runners]]\n      name = \"hexO\"\n      url = \"http://gitlab.capd.net/\"\n      token = \"75e82f2298901dfb7aec37a47bacae\"\n      executor = \"shell\"\n      [runners.cache]\n    \n    [[runners]]\n      name = \"asiainfo-hexo\"\n      url = \"http://gitlab.capd.net/\"\n      token = \"6765a30042ecdc79e41c2b085f2999\"\n      executor = \"shell\"\n      [runners.cache]\n    \n    [[runners]]\n      name = \"hexo-jiacy\"\n      url = \"http://10.1.241.33/\"\n      token = \"d9034efa87b159c7c98794cfad9f8f\"\n      executor = \"shell\"\n      [runners.cache]\n    ~     \n    到这里我们的Runner就安装配置好了，接下来是对项目根目录中.gitlab-ci.yml进行配置。               \n ##### （2）配置构建任务\n\n   （1）在项目根目录添加.gitlab-ci.yml文件\n   \n    image: node:8.11.2\n    \n    pages:\n      cache:\n        paths:\n        - node_modules/\n    \n      script:\n      - npm install hexo-cli -g\n      - npm install\n      - hexo deploy\n      artifacts:\n        paths:\n        - public\n      only:\n      - master\n      \n  （2）在项目根目录添加.gitlab-ci.yml文件\n  \n![upload successful](\\images\\hexo\\pasted-5.png)\n\n这样整个CI流程就配置完了，项目是hexo，就会生产我们的页面，在Pages中查看：\n\n![upload successful](\\images\\hexo\\pasted-6.png)\n\n之后每次push到git仓库代码的时候都会执行项目对应的任务：\n\n![upload successful](\\images\\hexo\\pasted-7.png)","categories":["研发工具"]},{"title":"Spark Streaming原理介绍","url":"/2018/08/29/spark-streaming-01/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nSpark Streaming是建立在Spark上的实时计算框架，通过它提供的丰富的API、基于内存的高速执行引擎，用户可以结合流式、批处理和交互试查询应用。本文将详细介绍Spark Streaming实时计算框架的原理与特点、适用场景。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n","categories":["大数据"]},{"title":"Windows 命令行","url":"/2018/08/29/windows/","content":"---\n** {{ title }}：** <Excerpt in index | 首页摘要>\n打开\"运行\"对话框（Win+R），输入cmd，打开控制台命令窗口...\n也可以通过cmd /c 命令 和 cmd /k 命令的方式来直接运行命令\n注：/c表示执行完命令后关闭cmd窗口；/k表示执行完命令后保留cmd窗口\n<!-- more -->\n<The rest of contents | 余下全文>\n\nwindows 命令行d\n\ndir (directory) ：列出当前目录下的文件以及文件夹\nmd (make directory)： 创建目录\nrd (remove directory)：删除目录\ncd (change directory)：进入指定目录\ncd.. : 退回到上一级目录\ncd\\ : 退回到根目录\ndel：删除文件\nexit：退出dos命令行\ncls (clear screen): 清屏\n\n有关某个命令的详细信息，请键入 HELP 命令名\nASSOC 显示或修改文件扩展名关联。\nATTRIB 显示或更改文件属性。\nBREAK 设置或清除扩展式 CTRL+C 检查。\nBCDEDIT 设置启动数据库中的属性以控制启动加载。\nCACLS 显示或修改文件的访问控制列表(ACL)。\nCALL 从另一个批处理程序调用这一个。\nCD 显示当前目录的名称或将其更改。\nCHCP 显示或设置活动代码页数。\nCHDIR 显示当前目录的名称或将其更改。\nCHKDSK 检查磁盘并显示状态报告。\nCHKNTFS 显示或修改启动时间磁盘检查。\nCLS 清除屏幕。\nCMD 打开另一个 Windows 命令解释程序窗口。\nCOLOR 设置默认控制台前景和背景颜色。\nCOMP 比较两个或两套文件的内容。\nCOMPACT 显示或更改 NTFS 分区上文件的压缩。\nCONVERT 将 FAT 卷转换成 NTFS。您不能转换\n当前驱动器。\nCOPY 将至少一个文件复制到另一个位置。\nDATE 显示或设置日期。\nDEL 删除至少一个文件。\nDIR 显示一个目录中的文件和子目录。\nDISKCOMP 比较两个软盘的内容。\nDISKCOPY 将一个软盘的内容复制到另一个软盘。\nDISKPART 显示或配置磁盘分区属性。\nDOSKEY 编辑命令行、调用 Windows 命令并创建宏。\nDRIVERQUERY 显示当前设备驱动程序状态和属性。\nECHO 显示消息，或将命令回显打开或关上。\nENDLOCAL 结束批文件中环境更改的本地化。\nERASE 删除一个或多个文件。\nEXIT 退出 CMD.EXE 程序(命令解释程序)。\nFC 比较两个文件或两个文件集并显示它们之间的不同。\nFIND 在一个或多个文件中搜索一个文本字符串。\nFINDSTR 在多个文件中搜索字符串。\nFOR 为一套文件中的每个文件运行一个指定的命令。\nFORMAT 格式化磁盘，以便跟 Windows 使用。\nFSUTIL 显示或配置文件系统的属性。\nFTYPE 显示或修改用在文件扩展名关联的文件类型。\nGOTO 将 Windows 命令解释程序指向批处理程序\n中某个带标签的行。\nGPRESULT 显示机器或用户的组策略信息。\nGRAFTABL 启用 Windows 在图形模式显示扩展字符集。\nHELP 提供 Windows 命令的帮助信息。\nICACLS 显示、修改、备份或还原文件和\n目录的 ACL。\nIF 在批处理程序中执行有条件的处理过程。\nLABEL 创建、更改或删除磁盘的卷标。\nMD 创建一个目录。\nMKDIR 创建一个目录。\nMKLINK 创建符号链接和硬链接\nMODE 配置系统设备。\nMORE 逐屏显示输出。\nMOVE 将一个或多个文件从一个目录移动到另一个目录。\nOPENFILES 显示远程用户为了文件共享而打开的文件。\nPATH 为可执行文件显示或设置搜索路径。\nPAUSE 停止批处理文件的处理并显示信息。\nPOPD 还原由 PUSHD 保存的当前目录上一次的值。\nPRINT 打印一个文本文件。\nPROMPT 改变 Windows 命令提示。\nPUSHD 保存当前目录，然后对其进行更改。\nRD 删除目录。\nRECOVER 从损坏的磁盘中恢复可读取的信息。\nREM 记录批处理文件或 CONFIG.SYS 中的注释。\nREN 重新命名文件。\nRENAME 重新命名文件。\nREPLACE 替换文件。\nRMDIR 删除目录。\nROBOCOPY 复制文件和目录树的高级实用程序\nSET 显示、设置或删除 Windows 环境变量。\nSETLOCAL 开始用批文件改变环境的本地化。\nSC 显示或配置服务(后台处理)。\nSCHTASKS 安排命令和程序在一部计算机上按计划运行。\nSHIFT 调整批处理文件中可替换参数的位置。\nSHUTDOWN 让机器在本地或远程正确关闭。\nSORT 将输入排序。\nSTART 打开单独视窗运行指定程序或命令。\nSUBST 将驱动器号与路径关联。\nSYSTEMINFO 显示机器的具体的属性和配置。\nTASKLIST 显示包括服务的所有当前运行的任务。\nTASKKILL 终止正在运行的进程或应用程序。\nTIME 显示或设置系统时间。\nTITLE 设置 CMD.EXE 会话的窗口标题。\nTREE 以图形显示启动器或路径的目录结构。\nTYPE 显示文本文件的内容。\nVER 显示 Windows 的版本。\nVERIFY 告诉 Windows 验证文件是否正确写入磁盘。\nVOL 显示磁盘卷标和序列号。\nXCOPY 复制文件和目录树。\nWMIC 在交互命令外壳里显示 WMI 信息。","categories":["语法手册"]},{"title":"Zookeeper安装部署手册","url":"/2018/08/29/zookeeper/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## Zookeeper安装部署手册\n### 一、环境配置\n\n### 二、操作步骤\n#### 1、下载zookeeper安装包\n    \n#### 2、将安装包上传解压到服务器指定目录\n    \n#### 3、对默认配置文件进行重命名\n    \n#### 4、修改zoo.cfg配置文件\n    \n    #发送心跳的间隔时间，单位：毫秒\n    tickTime=2000\n    #zookeeper保存数据的目录\n    dataDir=/modules/zookeeper-3.4.5-cdh5.11.1/data\n    #日志目录\n    dataLogDir=/modules/zookeeper-3.4.5-cdh5.11.1/dataLog\n    #端口\n    clientPort=2181\n    #leader和follower初始化连接时最长能忍受多少个心跳时间的间隔数\n    initLimit=5\n    #leader和follower之间发送消息，请求和英达时间长度，最长不能超过多少个tickTime的时间长度\n    syncLimit=2\n    #zookeeper机器列表，server.order这里的Order依据集群的机器个数依次进行递增，这里的server1、server2、server3表示机器IP地址\n    server.1=server1:2888:3888\n    server.2=server2:2888:3888\n    server.3=server3:2888:3888\n    \n#### 5、新建myid文件\n    \n    在server1机器中，在上面配置的data目录下，新建一个名为 myid的文件，文件内容填写 1，对的，没有听错，文件中只保留一个数字 1。\n    zookeeper是根据该文件来决定zookeeper集群各个机器的身份分配。\n    \n#### 6、将配置好的zookeeper分发到集群的所有机器\n    经过上面的五个步骤zookeeper已经配置完毕，然后将其依次拷贝的集群的其他机器中。快捷一点可以使用 scp 命令来做这件事\n    然后修改data目录的下的myid 文件中的数字，在这里即为将server2的myid内容修改为2，将server3的myid内容修改为3。对于不同的集群，根据需要进行修改，与配置文件中的order保持一致。\n    \n#### 7、启动zookeeper服务\n    \n    修改完成后，在每台机器上依次使用bin/zkServer.sh start来启动zookeeper服务，\n    待启动完成后使用 bin/zkServer.sh status来查看该机器的身份 \n    \n#### 8、启动zookeeper客户端检验服务是否可用\n    使用 bin/zkCli.sh来检验zookeeper是否可以连接成功，若出现如下提示，则表示zookeeper服务已经安装成功。","categories":["大数据"]},{"title":"MarkDown","url":"/2018/08/29/markdown/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nMarkdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n<!-- more -->\n<The rest of contents | 余下全文>\n\nmarkdown基本语法\n\n一、标题\n    在想要设置为标题的文字前面加#来表示\n    一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。\n\n二、字体\n\n    加粗\n    要加粗的文字左右分别用两个*号包起来\n    \n    斜体\n    要倾斜的文字左右分别用一个*号包起来\n    \n    斜体加粗\n    要倾斜和加粗的文字左右分别用三个*号包起来\n    \n    删除线\n    要加删除线的文字左右分别用两个~~号包起来\n\n三、引用\n    在引用的文字前加>即可。引用也可以嵌套，如加两个>>三个>>>\n    n个...\n    貌似可以一直加下去，但没神马卵用\n\n四、分割线\n    三个或者三个以上的 - 或者 * 都可以。\n\n五、图片\n    \n    ![图片alt](图片地址 ''图片title'')\n    \n    图片alt就是显示在图片下面的文字，相当于对图片内容的解释。\n    图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加\n\n    示例：\n    ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/\n    u=702257389,1274025419&fm=27&gp=0.jpg \"区块链\")\n六、超链接\n    超链接名](超链接地址 \"超链接title\")\n    title可加可不加\n    示例：\n    [简书](http://jianshu.com)\n    [百度](http://baidu.com)\n\n    <a href=\"超链接地址\" target=\"_blank\">超链接名</a>\n    例<a href=\"https://www.jianshu.com/u/1f5ac0cf6a8b\" target=\"_blank\">简书</a>\n七、列表\n* 无序列表\n    无序列表用 - + * 任何一种都可以\n* 有序列表\n    数字加点\n* 列表嵌套\n    上一级和下一级之间敲三个空格即可\n\n八、表格\n| Tables | Are | Cool |\n| ------------- |:-------------:| -----:|\n| col 3 is | right-aligned | $1600 |\n| zebra stripes | are neat | $1 |\n\n    通过使用“|”符号分割表格的每格，以及“-”减号及“:”冒号表示对齐方式，减号的个数不限，但减号至少要有一个\n\n    若没有冒号或冒号在减号左边表示左对齐\n    减号两边都有表示中间对齐\n    若在减号右边表示右对齐\n    第一行表格每类的名字一定要有以及减号和冒号的一行也一定要有，第一行属性会自动黑体加粗，即第一行是表格属性名，第二行则是表格对齐方式，第三行是表格输出的第一行内容，第四行是第二行内容，以此类推\n\n    注意上述的冒号一定要是英文模式下输入，不可在中文形式，一定要注意\n    \n九、代码\n    单行代码：代码之间分别用一个反引号包起来\n    \n    ```\n    public static void main(){\n        system.out.println(\"Hello World！\");\n    }\n    ```\n    \n十、流程图\n```flow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n&```","categories":["语法手册"]},{"title":"分布式锁的几种实现方式","url":"/2018/03/02/dslock/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n在分布式架构中，由于多线程和多台服务器，何难保证顺序性。如果需要对某一个资源进行限制，比如票务，比如请求幂等性控制等，这个时候分布式锁就排上用处。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 什么是分布式锁\n分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。\n\n## 分布式锁需要解决的问题\n1. 互斥性：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁。\n2. 安全性：锁只能被持有该锁的客户端删除，不能由其它客户端删除。\n3. 死锁：获取锁的客户端因为某些原因（如down机等）而未能释放锁，其它客户端再也无法获取到该锁。\n4. 容错：当部分节点（redis节点等）down机时，客户端仍然能够获取锁和释放锁。\n\n## 分布式锁的实现方式\n1. 数据库实现\n\n2. 缓存实现，比如redis\n\n3. zookeeper实现\n\n## 未完待续\n","tags":["java"],"categories":["分布式架构"]},{"title":"分布式系统理论基础","url":"/2018/02/26/dsbasic/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n分布式系统不是万能，不能解决所有痛点。在高可用，一致性，分区容错性必须有所权衡。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## CAP理论\n定理：任何分布式架构都只能同时满足两点，无法三者兼顾。\n* Consistency（一致性），数据一致更新，所有的数据变动都是同步的。\n* Availability（可用性），好的响应性能。\n* Partition tolerance（分区容忍性）可靠性，机器宕机是否影响使用。\n\n关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区：\n1. Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。\n2. Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。\n3. Isolation隔离性. 事务将假定只有它自己在操作数据库，彼此不知晓。\n4. Durability持久性 一旦事务完成，就不能返回。\n跨数据库两段提交事务：2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland)\n是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。\n\n## BASE理论\n* Basically Available 基本可用，支持分区失败\n* Soft state 软状态，允许状态某个时间短不同步，或者异步\n* Eventually consistent 最终一致性，要求数据最终结果一致，而不是时刻高度一致。\n\n## paxos协议\nPaxos算法的目的是为了解决分布式环境下一致性的问题。多个节点并发操纵数据，如何保证在读写过程中数据的一致性，并且解决方案要能适应分布式环境下的不可靠性（系统如何就一个值达到统一）。\n### Paxos的两个组件:\n* Proposer：提议发起者，处理客户端请求，将客户端的请求发送到集群中，以便决定这个值是否可以被批准。\n* Acceptor:提议批准者，负责处理接收到的提议，他们的回复就是一次投票。会存储一些状态来决定是否接收一个值\n\n### Paxos有两个原则\n1. 安全原则---保证不能做错的事\n    * a） 针对某个实例的表决只能有一个值被批准，不能出现一个被批准的值被另一个值覆盖的情况；(假设有一个值被多数Acceptor批准了，那么这个值就只能被学习)\n    * b） 每个节点只能学习到已经被批准的值，不能学习没有被批准的值。\n2. 存活原则---只要有多数服务器存活并且彼此间可以通信，最终都要做到的下列事情：\n    * a）最终会批准某个被提议的值；\n    * b）一个值被批准了，其他服务器最终会学习到这个值。\n\n## zab协议(ZooKeeper Atomic broadcast protocol)\nZAB协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。\n\n### Phase 0: Leader election（选举阶段）\n节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 Phase 3 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。\n\n### Phase 1: Discovery（发现阶段）\n在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且准 leader 生成新的 epoch，让 followers 接受，更新它们的 acceptedEpoch。\n一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入 Phase 0。\n\n### Phase 2: Synchronization（同步阶段）\n同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。只有当 quorum 都同步完成，准 leader 才会成为真正的 leader。follower 只会接收 zxid 比自己的 lastZxid 大的提议。\n\n### Phase 3: Broadcast（广播阶段）\n到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。\n\n## raft协议\n在Raft中，每个结点会处于下面三种状态中的一种：\n### follower\n所有结点都以follower的状态开始。如果没收到leader消息则会变成candidate状态。\n### candidate\n会向其他结点“拉选票”，如果得到大部分的票则成为leader。这个过程就叫做Leader选举(Leader Election)\n### leader\n所有对系统的修改都会先经过leader。每个修改都会写一条日志(log entry)。leader收到修改请求后的过程如下，这个过程叫做日志复制(Log Replication)：\n\n    1. 复制日志到所有follower结点(replicate entry)\n    2. 大部分结点响应时才提交日志\n    3. 通知所有follower结点日志已提交\n    4. 所有follower也提交日志\n    5. 现在整个系统处于一致的状态\n\n\n\n","tags":["protocol"],"categories":["分布式架构"]}]